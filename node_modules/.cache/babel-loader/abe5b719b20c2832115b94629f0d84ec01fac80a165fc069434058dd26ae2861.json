{"ast":null,"code":"/*! @azure/msal-browser v4.13.1 2025-06-10 */\n'use strict';\n\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { PerformanceEvents } from '@azure/msal-common/browser';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.mjs';\nimport { urlEncodeArr, base64Encode } from '../encode/Base64Encode.mjs';\nimport { base64DecToArr, base64Decode } from '../encode/Base64Decode.mjs';\nimport { nonBrowserEnvironment, cryptoNonExistent, failedToDecryptEarResponse } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This file defines functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\n// Algorithms\nconst PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\nconst AES_GCM = \"AES-GCM\";\nconst HKDF = \"HKDF\";\n// SHA-256 hashing algorithm\nconst S256_HASH_ALG = \"SHA-256\";\n// MOD length for PoP tokens\nconst MODULUS_LENGTH = 2048;\n// Public Exponent\nconst PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);\n// UUID hex digits\nconst UUID_CHARS = \"0123456789abcdef\";\n// Array to store UINT32 random value\nconst UINT32_ARR = new Uint32Array(1);\n// Key Format\nconst RAW = \"raw\";\n// Key Usages\nconst ENCRYPT = \"encrypt\";\nconst DECRYPT = \"decrypt\";\nconst DERIVE_KEY = \"deriveKey\";\n// Suberror\nconst SUBTLE_SUBERROR = \"crypto_subtle_undefined\";\nconst keygenAlgorithmOptions = {\n  name: PKCS1_V15_KEYGEN_ALG,\n  hash: S256_HASH_ALG,\n  modulusLength: MODULUS_LENGTH,\n  publicExponent: PUBLIC_EXPONENT\n};\n/**\r\n * Check whether browser crypto is available.\r\n */\nfunction validateCryptoAvailable(skipValidateSubtleCrypto) {\n  if (!window) {\n    throw createBrowserAuthError(nonBrowserEnvironment);\n  }\n  if (!window.crypto) {\n    throw createBrowserAuthError(cryptoNonExistent);\n  }\n  if (!skipValidateSubtleCrypto && !window.crypto.subtle) {\n    throw createBrowserAuthError(cryptoNonExistent, SUBTLE_SUBERROR);\n  }\n}\n/**\r\n * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n * @param dataString {string} data string\r\n * @param performanceClient {?IPerformanceClient}\r\n * @param correlationId {?string} correlation id\r\n */\nasync function sha256Digest(dataString, performanceClient, correlationId) {\n  performanceClient?.addQueueMeasurement(PerformanceEvents.Sha256Digest, correlationId);\n  const encoder = new TextEncoder();\n  const data = encoder.encode(dataString);\n  return window.crypto.subtle.digest(S256_HASH_ALG, data);\n}\n/**\r\n * Populates buffer with cryptographically random values.\r\n * @param dataBuffer\r\n */\nfunction getRandomValues(dataBuffer) {\n  return window.crypto.getRandomValues(dataBuffer);\n}\n/**\r\n * Returns random Uint32 value.\r\n * @returns {number}\r\n */\nfunction getRandomUint32() {\n  window.crypto.getRandomValues(UINT32_ARR);\n  return UINT32_ARR[0];\n}\n/**\r\n * Creates a UUID v7 from the current timestamp.\r\n * Implementation relies on the system clock to guarantee increasing order of generated identifiers.\r\n * @returns {number}\r\n */\nfunction createNewGuid() {\n  const currentTimestamp = Date.now();\n  const baseRand = getRandomUint32() * 0x400 + (getRandomUint32() & 0x3ff);\n  // Result byte array\n  const bytes = new Uint8Array(16);\n  // A 12-bit `rand_a` field value\n  const randA = Math.trunc(baseRand / 2 ** 30);\n  // The higher 30 bits of 62-bit `rand_b` field value\n  const randBHi = baseRand & 2 ** 30 - 1;\n  // The lower 32 bits of 62-bit `rand_b` field value\n  const randBLo = getRandomUint32();\n  bytes[0] = currentTimestamp / 2 ** 40;\n  bytes[1] = currentTimestamp / 2 ** 32;\n  bytes[2] = currentTimestamp / 2 ** 24;\n  bytes[3] = currentTimestamp / 2 ** 16;\n  bytes[4] = currentTimestamp / 2 ** 8;\n  bytes[5] = currentTimestamp;\n  bytes[6] = 0x70 | randA >>> 8;\n  bytes[7] = randA;\n  bytes[8] = 0x80 | randBHi >>> 24;\n  bytes[9] = randBHi >>> 16;\n  bytes[10] = randBHi >>> 8;\n  bytes[11] = randBHi;\n  bytes[12] = randBLo >>> 24;\n  bytes[13] = randBLo >>> 16;\n  bytes[14] = randBLo >>> 8;\n  bytes[15] = randBLo;\n  let text = \"\";\n  for (let i = 0; i < bytes.length; i++) {\n    text += UUID_CHARS.charAt(bytes[i] >>> 4);\n    text += UUID_CHARS.charAt(bytes[i] & 0xf);\n    if (i === 3 || i === 5 || i === 7 || i === 9) {\n      text += \"-\";\n    }\n  }\n  return text;\n}\n/**\r\n * Generates a keypair based on current keygen algorithm config.\r\n * @param extractable\r\n * @param usages\r\n */\nasync function generateKeyPair(extractable, usages) {\n  return window.crypto.subtle.generateKey(keygenAlgorithmOptions, extractable, usages);\n}\n/**\r\n * Export key as Json Web Key (JWK)\r\n * @param key\r\n */\nasync function exportJwk(key) {\n  return window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key);\n}\n/**\r\n * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n * @param key\r\n * @param extractable\r\n * @param usages\r\n */\nasync function importJwk(key, extractable, usages) {\n  return window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, keygenAlgorithmOptions, extractable, usages);\n}\n/**\r\n * Signs given data with given key\r\n * @param key\r\n * @param data\r\n */\nasync function sign(key, data) {\n  return window.crypto.subtle.sign(keygenAlgorithmOptions, key, data);\n}\n/**\r\n * Generates Base64 encoded jwk used in the Encrypted Authorize Response (EAR) flow\r\n */\nasync function generateEarKey() {\n  const key = await generateBaseKey();\n  const keyStr = urlEncodeArr(new Uint8Array(key));\n  const jwk = {\n    alg: \"dir\",\n    kty: \"oct\",\n    k: keyStr\n  };\n  return base64Encode(JSON.stringify(jwk));\n}\n/**\r\n * Parses earJwk for encryption key and returns CryptoKey object\r\n * @param earJwk\r\n * @returns\r\n */\nasync function importEarKey(earJwk) {\n  const b64DecodedJwk = base64Decode(earJwk);\n  const jwkJson = JSON.parse(b64DecodedJwk);\n  const rawKey = jwkJson.k;\n  const keyBuffer = base64DecToArr(rawKey);\n  return window.crypto.subtle.importKey(RAW, keyBuffer, AES_GCM, false, [DECRYPT]);\n}\n/**\r\n * Decrypt ear_jwe response returned in the Encrypted Authorize Response (EAR) flow\r\n * @param earJwk\r\n * @param earJwe\r\n * @returns\r\n */\nasync function decryptEarResponse(earJwk, earJwe) {\n  const earJweParts = earJwe.split(\".\");\n  if (earJweParts.length !== 5) {\n    throw createBrowserAuthError(failedToDecryptEarResponse, \"jwe_length\");\n  }\n  const key = await importEarKey(earJwk).catch(() => {\n    throw createBrowserAuthError(failedToDecryptEarResponse, \"import_key\");\n  });\n  try {\n    const header = new TextEncoder().encode(earJweParts[0]);\n    const iv = base64DecToArr(earJweParts[2]);\n    const ciphertext = base64DecToArr(earJweParts[3]);\n    const tag = base64DecToArr(earJweParts[4]);\n    const tagLengthBits = tag.byteLength * 8;\n    // Concat ciphertext and tag\n    const encryptedData = new Uint8Array(ciphertext.length + tag.length);\n    encryptedData.set(ciphertext);\n    encryptedData.set(tag, ciphertext.length);\n    const decryptedData = await window.crypto.subtle.decrypt({\n      name: AES_GCM,\n      iv: iv,\n      tagLength: tagLengthBits,\n      additionalData: header\n    }, key, encryptedData);\n    return new TextDecoder().decode(decryptedData);\n  } catch (e) {\n    throw createBrowserAuthError(failedToDecryptEarResponse, \"decrypt\");\n  }\n}\n/**\r\n * Generates symmetric base encryption key. This may be stored as all encryption/decryption keys will be derived from this one.\r\n */\nasync function generateBaseKey() {\n  const key = await window.crypto.subtle.generateKey({\n    name: AES_GCM,\n    length: 256\n  }, true, [ENCRYPT, DECRYPT]);\n  return window.crypto.subtle.exportKey(RAW, key);\n}\n/**\r\n * Returns the raw key to be passed into the key derivation function\r\n * @param baseKey\r\n * @returns\r\n */\nasync function generateHKDF(baseKey) {\n  return window.crypto.subtle.importKey(RAW, baseKey, HKDF, false, [DERIVE_KEY]);\n}\n/**\r\n * Given a base key and a nonce generates a derived key to be used in encryption and decryption.\r\n * Note: every time we encrypt a new key is derived\r\n * @param baseKey\r\n * @param nonce\r\n * @returns\r\n */\nasync function deriveKey(baseKey, nonce, context) {\n  return window.crypto.subtle.deriveKey({\n    name: HKDF,\n    salt: nonce,\n    hash: S256_HASH_ALG,\n    info: new TextEncoder().encode(context)\n  }, baseKey, {\n    name: AES_GCM,\n    length: 256\n  }, false, [ENCRYPT, DECRYPT]);\n}\n/**\r\n * Encrypt the given data given a base key. Returns encrypted data and a nonce that must be provided during decryption\r\n * @param key\r\n * @param rawData\r\n */\nasync function encrypt(baseKey, rawData, context) {\n  const encodedData = new TextEncoder().encode(rawData);\n  // The nonce must never be reused with a given key.\n  const nonce = window.crypto.getRandomValues(new Uint8Array(16));\n  const derivedKey = await deriveKey(baseKey, nonce, context);\n  const encryptedData = await window.crypto.subtle.encrypt({\n    name: AES_GCM,\n    iv: new Uint8Array(12) // New key is derived for every encrypt so we don't need a new nonce\n  }, derivedKey, encodedData);\n  return {\n    data: urlEncodeArr(new Uint8Array(encryptedData)),\n    nonce: urlEncodeArr(nonce)\n  };\n}\n/**\r\n * Decrypt data with the given key and nonce\r\n * @param key\r\n * @param nonce\r\n * @param encryptedData\r\n * @returns\r\n */\nasync function decrypt(baseKey, nonce, context, encryptedData) {\n  const encodedData = base64DecToArr(encryptedData);\n  const derivedKey = await deriveKey(baseKey, base64DecToArr(nonce), context);\n  const decryptedData = await window.crypto.subtle.decrypt({\n    name: AES_GCM,\n    iv: new Uint8Array(12) // New key is derived for every encrypt so we don't need a new nonce\n  }, derivedKey, encodedData);\n  return new TextDecoder().decode(decryptedData);\n}\n/**\r\n * Returns the SHA-256 hash of an input string\r\n * @param plainText\r\n */\nasync function hashString(plainText) {\n  const hashBuffer = await sha256Digest(plainText);\n  const hashBytes = new Uint8Array(hashBuffer);\n  return urlEncodeArr(hashBytes);\n}\nexport { createNewGuid, decrypt, decryptEarResponse, encrypt, exportJwk, generateBaseKey, generateEarKey, generateHKDF, generateKeyPair, getRandomValues, hashString, importEarKey, importJwk, sha256Digest, sign, validateCryptoAvailable };","map":{"version":3,"names":["PKCS1_V15_KEYGEN_ALG","AES_GCM","HKDF","S256_HASH_ALG","MODULUS_LENGTH","PUBLIC_EXPONENT","Uint8Array","UUID_CHARS","UINT32_ARR","Uint32Array","RAW","ENCRYPT","DECRYPT","DERIVE_KEY","SUBTLE_SUBERROR","keygenAlgorithmOptions","name","hash","modulusLength","publicExponent","validateCryptoAvailable","skipValidateSubtleCrypto","window","createBrowserAuthError","nonBrowserEnvironment","crypto","cryptoNonExistent","subtle","sha256Digest","dataString","performanceClient","correlationId","addQueueMeasurement","PerformanceEvents","Sha256Digest","encoder","TextEncoder","data","encode","digest","getRandomValues","dataBuffer","getRandomUint32","createNewGuid","currentTimestamp","Date","now","baseRand","bytes","randA","Math","trunc","randBHi","randBLo","text","i","length","charAt","generateKeyPair","extractable","usages","generateKey","exportJwk","key","exportKey","KEY_FORMAT_JWK","importJwk","importKey","sign","generateEarKey","generateBaseKey","keyStr","urlEncodeArr","jwk","alg","kty","k","base64Encode","JSON","stringify","importEarKey","earJwk","b64DecodedJwk","base64Decode","jwkJson","parse","rawKey","keyBuffer","base64DecToArr","decryptEarResponse","earJwe","earJweParts","split","failedToDecryptEarResponse","catch","header","iv","ciphertext","tag","tagLengthBits","byteLength","encryptedData","set","decryptedData","decrypt","tagLength","additionalData","TextDecoder","decode","e","generateHKDF","baseKey","deriveKey","nonce","context","salt","info","encrypt","rawData","encodedData","derivedKey","hashString","plainText","hashBuffer","hashBytes"],"sources":["/Users/yuri.narang/Desktop/bondly-workplace-community-hub/node_modules/@azure/msal-browser/src/crypto/BrowserCrypto.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError.js\";\nimport {\n    IPerformanceClient,\n    PerformanceEvents,\n} from \"@azure/msal-common/browser\";\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants.js\";\nimport { base64Encode, urlEncodeArr } from \"../encode/Base64Encode.js\";\nimport { base64Decode, base64DecToArr } from \"../encode/Base64Decode.js\";\n\n/**\n * This file defines functions used by the browser library to perform cryptography operations such as\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\n */\n\n/**\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\n */\n// Algorithms\nconst PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\nconst AES_GCM = \"AES-GCM\";\nconst HKDF = \"HKDF\";\n// SHA-256 hashing algorithm\nconst S256_HASH_ALG = \"SHA-256\";\n// MOD length for PoP tokens\nconst MODULUS_LENGTH = 2048;\n// Public Exponent\nconst PUBLIC_EXPONENT: Uint8Array = new Uint8Array([0x01, 0x00, 0x01]);\n// UUID hex digits\nconst UUID_CHARS = \"0123456789abcdef\";\n// Array to store UINT32 random value\nconst UINT32_ARR = new Uint32Array(1);\n\n// Key Format\nconst RAW = \"raw\";\n// Key Usages\nconst ENCRYPT = \"encrypt\";\nconst DECRYPT = \"decrypt\";\nconst DERIVE_KEY = \"deriveKey\";\n\n// Suberror\nconst SUBTLE_SUBERROR = \"crypto_subtle_undefined\";\n\nconst keygenAlgorithmOptions: RsaHashedKeyGenParams = {\n    name: PKCS1_V15_KEYGEN_ALG,\n    hash: S256_HASH_ALG,\n    modulusLength: MODULUS_LENGTH,\n    publicExponent: PUBLIC_EXPONENT,\n};\n\n/**\n * Check whether browser crypto is available.\n */\nexport function validateCryptoAvailable(\n    skipValidateSubtleCrypto: boolean\n): void {\n    if (!window) {\n        throw createBrowserAuthError(\n            BrowserAuthErrorCodes.nonBrowserEnvironment\n        );\n    }\n    if (!window.crypto) {\n        throw createBrowserAuthError(BrowserAuthErrorCodes.cryptoNonExistent);\n    }\n    if (!skipValidateSubtleCrypto && !window.crypto.subtle) {\n        throw createBrowserAuthError(\n            BrowserAuthErrorCodes.cryptoNonExistent,\n            SUBTLE_SUBERROR\n        );\n    }\n}\n\n/**\n * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\n * @param dataString {string} data string\n * @param performanceClient {?IPerformanceClient}\n * @param correlationId {?string} correlation id\n */\nexport async function sha256Digest(\n    dataString: string,\n    performanceClient?: IPerformanceClient,\n    correlationId?: string\n): Promise<ArrayBuffer> {\n    performanceClient?.addQueueMeasurement(\n        PerformanceEvents.Sha256Digest,\n        correlationId\n    );\n    const encoder = new TextEncoder();\n    const data = encoder.encode(dataString);\n    return window.crypto.subtle.digest(\n        S256_HASH_ALG,\n        data\n    ) as Promise<ArrayBuffer>;\n}\n\n/**\n * Populates buffer with cryptographically random values.\n * @param dataBuffer\n */\nexport function getRandomValues(dataBuffer: Uint8Array): Uint8Array {\n    return window.crypto.getRandomValues(dataBuffer);\n}\n\n/**\n * Returns random Uint32 value.\n * @returns {number}\n */\nfunction getRandomUint32(): number {\n    window.crypto.getRandomValues(UINT32_ARR);\n    return UINT32_ARR[0];\n}\n\n/**\n * Creates a UUID v7 from the current timestamp.\n * Implementation relies on the system clock to guarantee increasing order of generated identifiers.\n * @returns {number}\n */\nexport function createNewGuid(): string {\n    const currentTimestamp = Date.now();\n    const baseRand = getRandomUint32() * 0x400 + (getRandomUint32() & 0x3ff);\n\n    // Result byte array\n    const bytes = new Uint8Array(16);\n    // A 12-bit `rand_a` field value\n    const randA = Math.trunc(baseRand / 2 ** 30);\n    // The higher 30 bits of 62-bit `rand_b` field value\n    const randBHi = baseRand & (2 ** 30 - 1);\n    // The lower 32 bits of 62-bit `rand_b` field value\n    const randBLo = getRandomUint32();\n\n    bytes[0] = currentTimestamp / 2 ** 40;\n    bytes[1] = currentTimestamp / 2 ** 32;\n    bytes[2] = currentTimestamp / 2 ** 24;\n    bytes[3] = currentTimestamp / 2 ** 16;\n    bytes[4] = currentTimestamp / 2 ** 8;\n    bytes[5] = currentTimestamp;\n    bytes[6] = 0x70 | (randA >>> 8);\n    bytes[7] = randA;\n    bytes[8] = 0x80 | (randBHi >>> 24);\n    bytes[9] = randBHi >>> 16;\n    bytes[10] = randBHi >>> 8;\n    bytes[11] = randBHi;\n    bytes[12] = randBLo >>> 24;\n    bytes[13] = randBLo >>> 16;\n    bytes[14] = randBLo >>> 8;\n    bytes[15] = randBLo;\n\n    let text = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        text += UUID_CHARS.charAt(bytes[i] >>> 4);\n        text += UUID_CHARS.charAt(bytes[i] & 0xf);\n        if (i === 3 || i === 5 || i === 7 || i === 9) {\n            text += \"-\";\n        }\n    }\n    return text;\n}\n\n/**\n * Generates a keypair based on current keygen algorithm config.\n * @param extractable\n * @param usages\n */\nexport async function generateKeyPair(\n    extractable: boolean,\n    usages: Array<KeyUsage>\n): Promise<CryptoKeyPair> {\n    return window.crypto.subtle.generateKey(\n        keygenAlgorithmOptions,\n        extractable,\n        usages\n    ) as Promise<CryptoKeyPair>;\n}\n\n/**\n * Export key as Json Web Key (JWK)\n * @param key\n */\nexport async function exportJwk(key: CryptoKey): Promise<JsonWebKey> {\n    return window.crypto.subtle.exportKey(\n        KEY_FORMAT_JWK,\n        key\n    ) as Promise<JsonWebKey>;\n}\n\n/**\n * Imports key as Json Web Key (JWK), can set extractable and usages.\n * @param key\n * @param extractable\n * @param usages\n */\nexport async function importJwk(\n    key: JsonWebKey,\n    extractable: boolean,\n    usages: Array<KeyUsage>\n): Promise<CryptoKey> {\n    return window.crypto.subtle.importKey(\n        KEY_FORMAT_JWK,\n        key,\n        keygenAlgorithmOptions,\n        extractable,\n        usages\n    ) as Promise<CryptoKey>;\n}\n\n/**\n * Signs given data with given key\n * @param key\n * @param data\n */\nexport async function sign(\n    key: CryptoKey,\n    data: ArrayBuffer\n): Promise<ArrayBuffer> {\n    return window.crypto.subtle.sign(\n        keygenAlgorithmOptions,\n        key,\n        data\n    ) as Promise<ArrayBuffer>;\n}\n\n/**\n * Generates Base64 encoded jwk used in the Encrypted Authorize Response (EAR) flow\n */\nexport async function generateEarKey(): Promise<string> {\n    const key = await generateBaseKey();\n    const keyStr = urlEncodeArr(new Uint8Array(key));\n\n    const jwk = {\n        alg: \"dir\",\n        kty: \"oct\",\n        k: keyStr,\n    };\n\n    return base64Encode(JSON.stringify(jwk));\n}\n\n/**\n * Parses earJwk for encryption key and returns CryptoKey object\n * @param earJwk\n * @returns\n */\nexport async function importEarKey(earJwk: string): Promise<CryptoKey> {\n    const b64DecodedJwk = base64Decode(earJwk);\n    const jwkJson = JSON.parse(b64DecodedJwk);\n    const rawKey = jwkJson.k;\n    const keyBuffer = base64DecToArr(rawKey);\n\n    return window.crypto.subtle.importKey(RAW, keyBuffer, AES_GCM, false, [\n        DECRYPT,\n    ]);\n}\n\n/**\n * Decrypt ear_jwe response returned in the Encrypted Authorize Response (EAR) flow\n * @param earJwk\n * @param earJwe\n * @returns\n */\nexport async function decryptEarResponse(\n    earJwk: string,\n    earJwe: string\n): Promise<string> {\n    const earJweParts = earJwe.split(\".\");\n    if (earJweParts.length !== 5) {\n        throw createBrowserAuthError(\n            BrowserAuthErrorCodes.failedToDecryptEarResponse,\n            \"jwe_length\"\n        );\n    }\n\n    const key = await importEarKey(earJwk).catch(() => {\n        throw createBrowserAuthError(\n            BrowserAuthErrorCodes.failedToDecryptEarResponse,\n            \"import_key\"\n        );\n    });\n\n    try {\n        const header = new TextEncoder().encode(earJweParts[0]);\n        const iv = base64DecToArr(earJweParts[2]);\n        const ciphertext = base64DecToArr(earJweParts[3]);\n        const tag = base64DecToArr(earJweParts[4]);\n        const tagLengthBits = tag.byteLength * 8;\n\n        // Concat ciphertext and tag\n        const encryptedData = new Uint8Array(ciphertext.length + tag.length);\n        encryptedData.set(ciphertext);\n        encryptedData.set(tag, ciphertext.length);\n\n        const decryptedData = await window.crypto.subtle.decrypt(\n            {\n                name: AES_GCM,\n                iv: iv,\n                tagLength: tagLengthBits,\n                additionalData: header,\n            },\n            key,\n            encryptedData\n        );\n\n        return new TextDecoder().decode(decryptedData);\n    } catch (e) {\n        throw createBrowserAuthError(\n            BrowserAuthErrorCodes.failedToDecryptEarResponse,\n            \"decrypt\"\n        );\n    }\n}\n\n/**\n * Generates symmetric base encryption key. This may be stored as all encryption/decryption keys will be derived from this one.\n */\nexport async function generateBaseKey(): Promise<ArrayBuffer> {\n    const key = await window.crypto.subtle.generateKey(\n        {\n            name: AES_GCM,\n            length: 256,\n        },\n        true,\n        [ENCRYPT, DECRYPT]\n    );\n    return window.crypto.subtle.exportKey(RAW, key);\n}\n\n/**\n * Returns the raw key to be passed into the key derivation function\n * @param baseKey\n * @returns\n */\nexport async function generateHKDF(baseKey: ArrayBuffer): Promise<CryptoKey> {\n    return window.crypto.subtle.importKey(RAW, baseKey, HKDF, false, [\n        DERIVE_KEY,\n    ]);\n}\n\n/**\n * Given a base key and a nonce generates a derived key to be used in encryption and decryption.\n * Note: every time we encrypt a new key is derived\n * @param baseKey\n * @param nonce\n * @returns\n */\nasync function deriveKey(\n    baseKey: CryptoKey,\n    nonce: ArrayBuffer,\n    context: string\n): Promise<CryptoKey> {\n    return window.crypto.subtle.deriveKey(\n        {\n            name: HKDF,\n            salt: nonce,\n            hash: S256_HASH_ALG,\n            info: new TextEncoder().encode(context),\n        },\n        baseKey,\n        { name: AES_GCM, length: 256 },\n        false,\n        [ENCRYPT, DECRYPT]\n    );\n}\n\n/**\n * Encrypt the given data given a base key. Returns encrypted data and a nonce that must be provided during decryption\n * @param key\n * @param rawData\n */\nexport async function encrypt(\n    baseKey: CryptoKey,\n    rawData: string,\n    context: string\n): Promise<{ data: string; nonce: string }> {\n    const encodedData = new TextEncoder().encode(rawData);\n    // The nonce must never be reused with a given key.\n    const nonce = window.crypto.getRandomValues(new Uint8Array(16));\n    const derivedKey = await deriveKey(baseKey, nonce, context);\n    const encryptedData = await window.crypto.subtle.encrypt(\n        {\n            name: AES_GCM,\n            iv: new Uint8Array(12), // New key is derived for every encrypt so we don't need a new nonce\n        },\n        derivedKey,\n        encodedData\n    );\n\n    return {\n        data: urlEncodeArr(new Uint8Array(encryptedData)),\n        nonce: urlEncodeArr(nonce),\n    };\n}\n\n/**\n * Decrypt data with the given key and nonce\n * @param key\n * @param nonce\n * @param encryptedData\n * @returns\n */\nexport async function decrypt(\n    baseKey: CryptoKey,\n    nonce: string,\n    context: string,\n    encryptedData: string\n): Promise<string> {\n    const encodedData = base64DecToArr(encryptedData);\n    const derivedKey = await deriveKey(baseKey, base64DecToArr(nonce), context);\n    const decryptedData = await window.crypto.subtle.decrypt(\n        {\n            name: AES_GCM,\n            iv: new Uint8Array(12), // New key is derived for every encrypt so we don't need a new nonce\n        },\n        derivedKey,\n        encodedData\n    );\n\n    return new TextDecoder().decode(decryptedData);\n}\n\n/**\n * Returns the SHA-256 hash of an input string\n * @param plainText\n */\nexport async function hashString(plainText: string): Promise<string> {\n    const hashBuffer: ArrayBuffer = await sha256Digest(plainText);\n    const hashBytes = new Uint8Array(hashBuffer);\n    return urlEncodeArr(hashBytes);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}