{"ast":null,"code":"/*! @azure/msal-common v15.7.0 2025-05-30 */\n'use strict';\n\nimport { BaseClient } from './BaseClient.mjs';\nimport { addClientId, addRedirectUri, addScopes, addAuthorizationCode, addLibraryInfo, addApplicationTelemetry, addThrottling, addServerTelemetry, addCodeVerifier, addClientSecret, addClientAssertion, addClientAssertionType, addGrantType, addClientInfo, addPopToken, addSshJwk, addClaims, addCcsUpn, addCcsOid, addBrokerParameters, addExtraQueryParameters, instrumentBrokerParams, addPostLogoutRedirectUri, addCorrelationId, addIdTokenHint, addState, addLogoutHint, addInstanceAware } from '../request/RequestParameterBuilder.mjs';\nimport { mapToQueryString } from '../utils/UrlUtils.mjs';\nimport { Separators, GrantType, AuthenticationScheme, HeaderNames } from '../utils/Constants.mjs';\nimport { CLIENT_ID, RETURN_SPA_CODE } from '../constants/AADServerParamKeys.mjs';\nimport { isOidcProtocolMode } from '../config/ClientConfiguration.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { nowSeconds } from '../utils/TimeUtils.mjs';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { CcsCredentialType } from '../account/CcsCredential.mjs';\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { RequestValidator } from '../request/RequestValidator.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { getClientAssertion } from '../utils/ClientAssertionUtils.mjs';\nimport { getRequestThumbprint } from '../network/RequestThumbprint.mjs';\nimport { requestCannotBeMade } from '../error/ClientAuthErrorCodes.mjs';\nimport { logoutRequestEmpty, missingSshJwk } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Oauth2.0 Authorization Code client\r\n * @internal\r\n */\nclass AuthorizationCodeClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    this.includeRedirectUri = true;\n    this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n  }\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n  async acquireToken(request, authCodePayload) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n    if (!request.code) {\n      throw createClientAuthError(requestCannotBeMade);\n    }\n    const reqTimestamp = nowSeconds();\n    const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);\n    // Retrieve requestId from response headers\n    const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);\n    // Validate response. This function throws a server error if an error is returned by the server.\n    responseHandler.validateTokenResponse(response.body);\n    return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);\n  }\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n  getLogoutUri(logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw createClientConfigurationError(logoutRequestEmpty);\n    }\n    const queryString = this.createLogoutUrlQueryString(logoutRequest);\n    // Construct logout URI\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  }\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n  async executeTokenRequest(authority, request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n    const queryParametersString = this.createTokenQueryParameters(request);\n    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n    const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);\n    let ccsCredential = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCredential = {\n          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    }\n    const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n    const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);\n    return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);\n  }\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n  async createTokenRequestBody(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n    const parameters = new Map();\n    addClientId(parameters, request.embeddedClientId || request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);\n    /*\r\n     * For hybrid spa flow, there will be a code but no verifier\r\n     * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n     */\n    if (!this.includeRedirectUri) {\n      // Just validate\n      RequestValidator.validateRedirectUri(request.redirectUri);\n    } else {\n      // Validate and include redirect uri\n      addRedirectUri(parameters, request.redirectUri);\n    }\n    // Add scope array, parameter builder will add default scopes and dedupe\n    addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);\n    // add code: user set, not validated\n    addAuthorizationCode(parameters, request.code);\n    // Add library metadata\n    addLibraryInfo(parameters, this.config.libraryInfo);\n    addApplicationTelemetry(parameters, this.config.telemetry.application);\n    addThrottling(parameters);\n    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n      addServerTelemetry(parameters, this.serverTelemetryManager);\n    }\n    // add code_verifier if passed\n    if (request.codeVerifier) {\n      addCodeVerifier(parameters, request.codeVerifier);\n    }\n    if (this.config.clientCredentials.clientSecret) {\n      addClientSecret(parameters, this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      const clientAssertion = this.config.clientCredentials.clientAssertion;\n      addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));\n      addClientAssertionType(parameters, clientAssertion.assertionType);\n    }\n    addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);\n    addClientInfo(parameters);\n    if (request.authenticationScheme === AuthenticationScheme.POP) {\n      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n      let reqCnfData;\n      if (!request.popKid) {\n        const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n        reqCnfData = generatedReqCnfData.reqCnfString;\n      } else {\n        reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n      }\n      // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n      addPopToken(parameters, reqCnfData);\n    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n      if (request.sshJwk) {\n        addSshJwk(parameters, request.sshJwk);\n      } else {\n        throw createClientConfigurationError(missingSshJwk);\n      }\n    }\n    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);\n    }\n    let ccsCred = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCred = {\n          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    } else {\n      ccsCred = request.ccsCredential;\n    }\n    // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n    if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n      switch (ccsCred.type) {\n        case CcsCredentialType.HOME_ACCOUNT_ID:\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n            addCcsOid(parameters, clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n          break;\n        case CcsCredentialType.UPN:\n          addCcsUpn(parameters, ccsCred.credential);\n          break;\n      }\n    }\n    if (request.embeddedClientId) {\n      addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);\n    }\n    if (request.tokenBodyParameters) {\n      addExtraQueryParameters(parameters, request.tokenBodyParameters);\n    }\n    // Add hybrid spa parameters if not already provided\n    if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {\n      addExtraQueryParameters(parameters, {\n        [RETURN_SPA_CODE]: \"1\"\n      });\n    }\n    instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);\n    return mapToQueryString(parameters);\n  }\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n  createLogoutUrlQueryString(request) {\n    const parameters = new Map();\n    if (request.postLogoutRedirectUri) {\n      addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);\n    }\n    if (request.correlationId) {\n      addCorrelationId(parameters, request.correlationId);\n    }\n    if (request.idTokenHint) {\n      addIdTokenHint(parameters, request.idTokenHint);\n    }\n    if (request.state) {\n      addState(parameters, request.state);\n    }\n    if (request.logoutHint) {\n      addLogoutHint(parameters, request.logoutHint);\n    }\n    if (request.extraQueryParameters) {\n      addExtraQueryParameters(parameters, request.extraQueryParameters);\n    }\n    if (this.config.authOptions.instanceAware) {\n      addInstanceAware(parameters);\n    }\n    return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);\n  }\n}\nexport { AuthorizationCodeClient };","map":{"version":3,"names":["AuthorizationCodeClient","BaseClient","constructor","configuration","performanceClient","includeRedirectUri","oidcDefaultScopes","config","authOptions","authority","options","OIDCOptions","defaultScopes","acquireToken","request","authCodePayload","addQueueMeasurement","PerformanceEvents","AuthClientAcquireToken","correlationId","code","createClientAuthError","requestCannotBeMade","reqTimestamp","nowSeconds","response","invokeAsync","executeTokenRequest","bind","AuthClientExecuteTokenRequest","logger","requestId","headers","HeaderNames","X_MS_REQUEST_ID","responseHandler","ResponseHandler","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","HandleServerTokenResponse","undefined","getLogoutUri","logoutRequest","createClientConfigurationError","logoutRequestEmpty","queryString","createLogoutUrlQueryString","UrlString","appendQueryString","endSessionEndpoint","queryParametersString","createTokenQueryParameters","endpoint","tokenEndpoint","requestBody","createTokenRequestBody","AuthClientCreateTokenRequestBody","ccsCredential","clientInfo","buildClientInfo","base64Decode","credential","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","verbose","createTokenRequestHeaders","thumbprint","getRequestThumbprint","executePostToTokenEndpoint","AuthorizationCodeClientExecutePostToTokenEndpoint","parameters","Map","addClientId","embeddedClientId","tokenBodyParameters","CLIENT_ID","RequestValidator","validateRedirectUri","redirectUri","addRedirectUri","addScopes","scopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","isOidcProtocolMode","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","getClientAssertion","assertion","resourceRequestUri","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","authenticationScheme","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","reqCnfData","popKid","generatedReqCnfData","generateCnf","PopTokenGenerateCnf","reqCnfString","encodeKid","addPopToken","SSH","sshJwk","addSshJwk","missingSshJwk","StringUtils","isEmptyObj","claims","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","addBrokerParameters","addExtraQueryParameters","enableSpaAuthorizationCode","RETURN_SPA_CODE","instrumentBrokerParams","mapToQueryString","postLogoutRedirectUri","addPostLogoutRedirectUri","addCorrelationId","idTokenHint","addIdTokenHint","state","addState","logoutHint","addLogoutHint","extraQueryParameters","instanceAware","addInstanceAware","encodeExtraQueryParams"],"sources":["/Users/yuri.narang/Desktop/bondly-workplace-community-hub/node_modules/@azure/msal-common/src/client/AuthorizationCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient.js\";\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest.js\";\nimport { Authority } from \"../authority/Authority.js\";\nimport * as RequestParameterBuilder from \"../request/RequestParameterBuilder.js\";\nimport * as UrlUtils from \"../utils/UrlUtils.js\";\nimport {\n    GrantType,\n    AuthenticationScheme,\n    Separators,\n    HeaderNames,\n} from \"../utils/Constants.js\";\nimport * as AADServerParamKeys from \"../constants/AADServerParamKeys.js\";\nimport {\n    ClientConfiguration,\n    isOidcProtocolMode,\n} from \"../config/ClientConfiguration.js\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse.js\";\nimport { NetworkResponse } from \"../network/NetworkResponse.js\";\nimport { ResponseHandler } from \"../response/ResponseHandler.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { StringUtils } from \"../utils/StringUtils.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError.js\";\nimport { UrlString } from \"../url/UrlString.js\";\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest.js\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator.js\";\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload.js\";\nimport * as TimeUtils from \"../utils/TimeUtils.js\";\nimport {\n    buildClientInfoFromHomeAccountId,\n    buildClientInfo,\n} from \"../account/ClientInfo.js\";\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential.js\";\nimport {\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n} from \"../error/ClientConfigurationError.js\";\nimport { RequestValidator } from \"../request/RequestValidator.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport { invokeAsync } from \"../utils/FunctionWrappers.js\";\nimport { ClientAssertion } from \"../account/ClientCredentials.js\";\nimport { getClientAssertion } from \"../utils/ClientAssertionUtils.js\";\nimport { getRequestThumbprint } from \"../network/RequestThumbprint.js\";\n\n/**\n * Oauth2.0 Authorization Code client\n * @internal\n */\nexport class AuthorizationCodeClient extends BaseClient {\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    protected includeRedirectUri: boolean = true;\n    private oidcDefaultScopes;\n\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n        this.oidcDefaultScopes =\n            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n    }\n\n    /**\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n     * authorization_code_grant\n     * @param request\n     */\n    async acquireToken(\n        request: CommonAuthorizationCodeRequest,\n        authCodePayload?: AuthorizationCodePayload\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientAcquireToken,\n            request.correlationId\n        );\n\n        if (!request.code) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.requestCannotBeMade\n            );\n        }\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await invokeAsync(\n            this.executeTokenRequest.bind(this),\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(this.authority, request);\n\n        // Retrieve requestId from response headers\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin,\n            this.performanceClient\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response.body);\n\n        return invokeAsync(\n            responseHandler.handleServerTokenResponse.bind(responseHandler),\n            PerformanceEvents.HandleServerTokenResponse,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request,\n            authCodePayload,\n            undefined,\n            undefined,\n            undefined,\n            requestId\n        );\n    }\n\n    /**\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param authorityUri\n     */\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\n        // Throw error if logoutRequest is null/undefined\n        if (!logoutRequest) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.logoutRequestEmpty\n            );\n        }\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\n\n        // Construct logout URI\n        return UrlString.appendQueryString(\n            this.authority.endSessionEndpoint,\n            queryString\n        );\n    }\n\n    /**\n     * Executes POST request to token endpoint\n     * @param authority\n     * @param request\n     */\n    private async executeTokenRequest(\n        authority: Authority,\n        request: CommonAuthorizationCodeRequest\n    ): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            request.correlationId\n        );\n\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n\n        const requestBody = await invokeAsync(\n            this.createTokenRequestBody.bind(this),\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n\n        let ccsCredential: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCredential = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        }\n        const headers: Record<string, string> = this.createTokenRequestHeaders(\n            ccsCredential || request.ccsCredential\n        );\n\n        const thumbprint = getRequestThumbprint(\n            this.config.authOptions.clientId,\n            request\n        );\n\n        return invokeAsync(\n            this.executePostToTokenEndpoint.bind(this),\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId,\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint\n        );\n    }\n\n    /**\n     * Generates a map for all the params to be sent to the service\n     * @param request\n     */\n    private async createTokenRequestBody(\n        request: CommonAuthorizationCodeRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            request.correlationId\n        );\n\n        const parameters = new Map<string, string>();\n\n        RequestParameterBuilder.addClientId(\n            parameters,\n            request.embeddedClientId ||\n                request.tokenBodyParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        /*\n         * For hybrid spa flow, there will be a code but no verifier\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n         */\n        if (!this.includeRedirectUri) {\n            // Just validate\n            RequestValidator.validateRedirectUri(request.redirectUri);\n        } else {\n            // Validate and include redirect uri\n            RequestParameterBuilder.addRedirectUri(\n                parameters,\n                request.redirectUri\n            );\n        }\n\n        // Add scope array, parameter builder will add default scopes and dedupe\n        RequestParameterBuilder.addScopes(\n            parameters,\n            request.scopes,\n            true,\n            this.oidcDefaultScopes\n        );\n\n        // add code: user set, not validated\n        RequestParameterBuilder.addAuthorizationCode(parameters, request.code);\n\n        // Add library metadata\n        RequestParameterBuilder.addLibraryInfo(\n            parameters,\n            this.config.libraryInfo\n        );\n        RequestParameterBuilder.addApplicationTelemetry(\n            parameters,\n            this.config.telemetry.application\n        );\n        RequestParameterBuilder.addThrottling(parameters);\n\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n            RequestParameterBuilder.addServerTelemetry(\n                parameters,\n                this.serverTelemetryManager\n            );\n        }\n\n        // add code_verifier if passed\n        if (request.codeVerifier) {\n            RequestParameterBuilder.addCodeVerifier(\n                parameters,\n                request.codeVerifier\n            );\n        }\n\n        if (this.config.clientCredentials.clientSecret) {\n            RequestParameterBuilder.addClientSecret(\n                parameters,\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion: ClientAssertion =\n                this.config.clientCredentials.clientAssertion;\n\n            RequestParameterBuilder.addClientAssertion(\n                parameters,\n                await getClientAssertion(\n                    clientAssertion.assertion,\n                    this.config.authOptions.clientId,\n                    request.resourceRequestUri\n                )\n            );\n            RequestParameterBuilder.addClientAssertionType(\n                parameters,\n                clientAssertion.assertionType\n            );\n        }\n\n        RequestParameterBuilder.addGrantType(\n            parameters,\n            GrantType.AUTHORIZATION_CODE_GRANT\n        );\n        RequestParameterBuilder.addClientInfo(parameters);\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(\n                this.cryptoUtils,\n                this.performanceClient\n            );\n\n            let reqCnfData;\n            if (!request.popKid) {\n                const generatedReqCnfData = await invokeAsync(\n                    popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                    PerformanceEvents.PopTokenGenerateCnf,\n                    this.logger,\n                    this.performanceClient,\n                    request.correlationId\n                )(request, this.logger);\n                reqCnfData = generatedReqCnfData.reqCnfString;\n            } else {\n                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);\n            }\n\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            RequestParameterBuilder.addPopToken(parameters, reqCnfData);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if (request.sshJwk) {\n                RequestParameterBuilder.addSshJwk(parameters, request.sshJwk);\n            } else {\n                throw createClientConfigurationError(\n                    ClientConfigurationErrorCodes.missingSshJwk\n                );\n            }\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            RequestParameterBuilder.addClaims(\n                parameters,\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        let ccsCred: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCred = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        } else {\n            ccsCred = request.ccsCredential;\n        }\n\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n            switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            ccsCred.credential\n                        );\n                        RequestParameterBuilder.addCcsOid(\n                            parameters,\n                            clientInfo\n                        );\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"Could not parse home account ID for CCS Header: \" +\n                                e\n                        );\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    RequestParameterBuilder.addCcsUpn(\n                        parameters,\n                        ccsCred.credential\n                    );\n                    break;\n            }\n        }\n\n        if (request.embeddedClientId) {\n            RequestParameterBuilder.addBrokerParameters(\n                parameters,\n                this.config.authOptions.clientId,\n                this.config.authOptions.redirectUri\n            );\n        }\n\n        if (request.tokenBodyParameters) {\n            RequestParameterBuilder.addExtraQueryParameters(\n                parameters,\n                request.tokenBodyParameters\n            );\n        }\n\n        // Add hybrid spa parameters if not already provided\n        if (\n            request.enableSpaAuthorizationCode &&\n            (!request.tokenBodyParameters ||\n                !request.tokenBodyParameters[\n                    AADServerParamKeys.RETURN_SPA_CODE\n                ])\n        ) {\n            RequestParameterBuilder.addExtraQueryParameters(parameters, {\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\",\n            });\n        }\n\n        RequestParameterBuilder.instrumentBrokerParams(\n            parameters,\n            request.correlationId,\n            this.performanceClient\n        );\n        return UrlUtils.mapToQueryString(parameters);\n    }\n\n    /**\n     * This API validates the `EndSessionRequest` and creates a URL\n     * @param request\n     */\n    private createLogoutUrlQueryString(\n        request: CommonEndSessionRequest\n    ): string {\n        const parameters = new Map<string, string>();\n\n        if (request.postLogoutRedirectUri) {\n            RequestParameterBuilder.addPostLogoutRedirectUri(\n                parameters,\n                request.postLogoutRedirectUri\n            );\n        }\n\n        if (request.correlationId) {\n            RequestParameterBuilder.addCorrelationId(\n                parameters,\n                request.correlationId\n            );\n        }\n\n        if (request.idTokenHint) {\n            RequestParameterBuilder.addIdTokenHint(\n                parameters,\n                request.idTokenHint\n            );\n        }\n\n        if (request.state) {\n            RequestParameterBuilder.addState(parameters, request.state);\n        }\n\n        if (request.logoutHint) {\n            RequestParameterBuilder.addLogoutHint(\n                parameters,\n                request.logoutHint\n            );\n        }\n\n        if (request.extraQueryParameters) {\n            RequestParameterBuilder.addExtraQueryParameters(\n                parameters,\n                request.extraQueryParameters\n            );\n        }\n\n        if (this.config.authOptions.instanceAware) {\n            RequestParameterBuilder.addInstanceAware(parameters);\n        }\n\n        return UrlUtils.mapToQueryString(\n            parameters,\n            this.config.authOptions.encodeExtraQueryParams,\n            request.extraQueryParameters\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}