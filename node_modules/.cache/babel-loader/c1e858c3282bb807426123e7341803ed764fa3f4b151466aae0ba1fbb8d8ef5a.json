{"ast":null,"code":"/*! @azure/msal-browser v4.13.1 2025-06-10 */\n'use strict';\n\nimport { PerformanceEvents, AuthorizeProtocol, ServerError, invokeAsync, CcsCredentialType } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Abstract class which defines operations for a browser interaction handling class.\r\n */\nclass InteractionHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function to handle response parameters from hash.\r\n   * @param locationHash\r\n   */\n  async handleCodeResponse(response, request) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponse, request.correlationId);\n    let authCodeResponse;\n    try {\n      authCodeResponse = AuthorizeProtocol.getAuthorizationCodePayload(response, request.state);\n    } catch (e) {\n      if (e instanceof ServerError && e.subError === userCancelled) {\n        // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n        throw createBrowserAuthError(userCancelled);\n      } else {\n        throw e;\n      }\n    }\n    return invokeAsync(this.handleCodeResponseFromServer.bind(this), PerformanceEvents.HandleCodeResponseFromServer, this.logger, this.performanceClient, request.correlationId)(authCodeResponse, request);\n  }\n  /**\r\n   * Process auth code response from AAD\r\n   * @param authCodeResponse\r\n   * @param state\r\n   * @param authority\r\n   * @param networkModule\r\n   * @returns\r\n   */\n  async handleCodeResponseFromServer(authCodeResponse, request, validateNonce = true) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, request.correlationId);\n    this.logger.trace(\"InteractionHandler.handleCodeResponseFromServer called\");\n    // Assign code to request\n    this.authCodeRequest.code = authCodeResponse.code;\n    // Check for new cloud instance\n    if (authCodeResponse.cloud_instance_host_name) {\n      await invokeAsync(this.authModule.updateAuthority.bind(this.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, this.logger, this.performanceClient, request.correlationId)(authCodeResponse.cloud_instance_host_name, request.correlationId);\n    }\n    // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n    if (validateNonce) {\n      // TODO: Assigning \"response nonce\" to \"request nonce\" is confusing. Refactor the function doing validation to accept request nonce directly\n      authCodeResponse.nonce = request.nonce || undefined;\n    }\n    authCodeResponse.state = request.state;\n    // Add CCS parameters if available\n    if (authCodeResponse.client_info) {\n      this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n    } else {\n      const ccsCred = this.createCcsCredentials(request);\n      if (ccsCred) {\n        this.authCodeRequest.ccsCredential = ccsCred;\n      }\n    }\n    // Acquire token with retrieved code.\n    const tokenResponse = await invokeAsync(this.authModule.acquireToken.bind(this.authModule), PerformanceEvents.AuthClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(this.authCodeRequest, authCodeResponse);\n    return tokenResponse;\n  }\n  /**\r\n   * Build ccs creds if available\r\n   */\n  createCcsCredentials(request) {\n    if (request.account) {\n      return {\n        credential: request.account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n    } else if (request.loginHint) {\n      return {\n        credential: request.loginHint,\n        type: CcsCredentialType.UPN\n      };\n    }\n    return null;\n  }\n}\nexport { InteractionHandler };","map":{"version":3,"names":["InteractionHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","performanceClient","authModule","browserStorage","handleCodeResponse","response","request","addQueueMeasurement","PerformanceEvents","HandleCodeResponse","correlationId","authCodeResponse","AuthorizeProtocol","getAuthorizationCodePayload","state","e","ServerError","subError","userCancelled","createBrowserAuthError","invokeAsync","handleCodeResponseFromServer","bind","HandleCodeResponseFromServer","validateNonce","trace","code","cloud_instance_host_name","updateAuthority","UpdateTokenEndpointAuthority","nonce","undefined","client_info","clientInfo","ccsCred","createCcsCredentials","ccsCredential","tokenResponse","acquireToken","AuthClientAcquireToken","account","credential","homeAccountId","type","CcsCredentialType","HOME_ACCOUNT_ID","loginHint","UPN"],"sources":["/Users/yuri.narang/Desktop/bondly-workplace-community-hub/node_modules/@azure/msal-browser/src/interaction_handler/InteractionHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodePayload,\n    CommonAuthorizationCodeRequest,\n    AuthorizationCodeClient,\n    CcsCredential,\n    Logger,\n    ServerError,\n    IPerformanceClient,\n    PerformanceEvents,\n    invokeAsync,\n    CcsCredentialType,\n    AuthorizeResponse,\n    AuthorizeProtocol,\n    CommonAuthorizationUrlRequest,\n} from \"@azure/msal-common/browser\";\n\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager.js\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\n\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nexport class InteractionHandler {\n    protected authModule: AuthorizationCodeClient;\n    protected browserStorage: BrowserCacheManager;\n    protected authCodeRequest: CommonAuthorizationCodeRequest;\n    protected logger: Logger;\n    protected performanceClient: IPerformanceClient;\n\n    constructor(\n        authCodeModule: AuthorizationCodeClient,\n        storageImpl: BrowserCacheManager,\n        authCodeRequest: CommonAuthorizationCodeRequest,\n        logger: Logger,\n        performanceClient: IPerformanceClient\n    ) {\n        this.authModule = authCodeModule;\n        this.browserStorage = storageImpl;\n        this.authCodeRequest = authCodeRequest;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Function to handle response parameters from hash.\n     * @param locationHash\n     */\n    async handleCodeResponse(\n        response: AuthorizeResponse,\n        request: CommonAuthorizationUrlRequest\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponse,\n            request.correlationId\n        );\n\n        let authCodeResponse;\n        try {\n            authCodeResponse = AuthorizeProtocol.getAuthorizationCodePayload(\n                response,\n                request.state\n            );\n        } catch (e) {\n            if (\n                e instanceof ServerError &&\n                e.subError === BrowserAuthErrorCodes.userCancelled\n            ) {\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.userCancelled\n                );\n            } else {\n                throw e;\n            }\n        }\n\n        return invokeAsync(\n            this.handleCodeResponseFromServer.bind(this),\n            PerformanceEvents.HandleCodeResponseFromServer,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(authCodeResponse, request);\n    }\n\n    /**\n     * Process auth code response from AAD\n     * @param authCodeResponse\n     * @param state\n     * @param authority\n     * @param networkModule\n     * @returns\n     */\n    async handleCodeResponseFromServer(\n        authCodeResponse: AuthorizationCodePayload,\n        request: CommonAuthorizationUrlRequest,\n        validateNonce: boolean = true\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponseFromServer,\n            request.correlationId\n        );\n        this.logger.trace(\n            \"InteractionHandler.handleCodeResponseFromServer called\"\n        );\n\n        // Assign code to request\n        this.authCodeRequest.code = authCodeResponse.code;\n\n        // Check for new cloud instance\n        if (authCodeResponse.cloud_instance_host_name) {\n            await invokeAsync(\n                this.authModule.updateAuthority.bind(this.authModule),\n                PerformanceEvents.UpdateTokenEndpointAuthority,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )(authCodeResponse.cloud_instance_host_name, request.correlationId);\n        }\n\n        // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n        if (validateNonce) {\n            // TODO: Assigning \"response nonce\" to \"request nonce\" is confusing. Refactor the function doing validation to accept request nonce directly\n            authCodeResponse.nonce = request.nonce || undefined;\n        }\n\n        authCodeResponse.state = request.state;\n\n        // Add CCS parameters if available\n        if (authCodeResponse.client_info) {\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n        } else {\n            const ccsCred = this.createCcsCredentials(request);\n            if (ccsCred) {\n                this.authCodeRequest.ccsCredential = ccsCred;\n            }\n        }\n\n        // Acquire token with retrieved code.\n        const tokenResponse = (await invokeAsync(\n            this.authModule.acquireToken.bind(this.authModule),\n            PerformanceEvents.AuthClientAcquireToken,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(this.authCodeRequest, authCodeResponse)) as AuthenticationResult;\n        return tokenResponse;\n    }\n\n    /**\n     * Build ccs creds if available\n     */\n    protected createCcsCredentials(\n        request: CommonAuthorizationUrlRequest\n    ): CcsCredential | null {\n        if (request.account) {\n            return {\n                credential: request.account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            };\n        } else if (request.loginHint) {\n            return {\n                credential: request.loginHint,\n                type: CcsCredentialType.UPN,\n            };\n        }\n\n        return null;\n    }\n}\n"],"mappings":";;;;;;;AAAA;;;AAGG;AAyBH;;AAEG;MACUA,kBAAkB;EAO3BC,WACIA,CAAAC,cAAuC,EACvCC,WAAgC,EAChCC,eAA+C,EAC/CC,MAAc,EACdC,iBAAqC;IAErC,IAAI,CAACC,UAAU,GAAGL,cAAc;IAChC,IAAI,CAACM,cAAc,GAAGL,WAAW;IACjC,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,iBAAiB,GAAGA,iBAAiB;;EAG9C;;;AAGG;EACH,MAAMG,kBAAkBA,CACpBC,QAA2B,EAC3BC,OAAsC;IAEtC,IAAI,CAACL,iBAAiB,CAACM,mBAAmB,CACtCC,iBAAiB,CAACC,kBAAkB,EACpCH,OAAO,CAACI,aAAa,CACxB;IAED,IAAIC,gBAAgB;IACpB,IAAI;MACAA,gBAAgB,GAAGC,iBAAiB,CAACC,2BAA2B,CAC5DR,QAAQ,EACRC,OAAO,CAACQ,KAAK,CAChB;IACJ,EAAC,OAAOC,CAAC,EAAE;MACR,IACIA,CAAC,YAAYC,WAAW,IACxBD,CAAC,CAACE,QAAQ,KAAKC,aAAmC,EACpD;;QAEE,MAAMC,sBAAsB,CACxBD,aAAmC,CACtC;MACJ,OAAM;QACH,MAAMH,CAAC;MACV;IACJ;IAED,OAAOK,WAAW,CACd,IAAI,CAACC,4BAA4B,CAACC,IAAI,CAAC,IAAI,CAAC,EAC5Cd,iBAAiB,CAACe,4BAA4B,EAC9C,IAAI,CAACvB,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBK,OAAO,CAACI,aAAa,CACxB,CAACC,gBAAgB,EAAEL,OAAO,CAAC;;EAGhC;;;;;;;AAOG;EACH,MAAMe,4BAA4BA,CAC9BV,gBAA0C,EAC1CL,OAAsC,EACtCkB,aAAA,GAAyB,IAAI;IAE7B,IAAI,CAACvB,iBAAiB,CAACM,mBAAmB,CACtCC,iBAAiB,CAACe,4BAA4B,EAC9CjB,OAAO,CAACI,aAAa,CACxB;IACD,IAAI,CAACV,MAAM,CAACyB,KAAK,CACb,wDAAwD,CAC3D;;IAGD,IAAI,CAAC1B,eAAe,CAAC2B,IAAI,GAAGf,gBAAgB,CAACe,IAAI;;IAGjD,IAAIf,gBAAgB,CAACgB,wBAAwB,EAAE;MAC3C,MAAMP,WAAW,CACb,IAAI,CAAClB,UAAU,CAAC0B,eAAe,CAACN,IAAI,CAAC,IAAI,CAACpB,UAAU,CAAC,EACrDM,iBAAiB,CAACqB,4BAA4B,EAC9C,IAAI,CAAC7B,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBK,OAAO,CAACI,aAAa,CACxB,CAACC,gBAAgB,CAACgB,wBAAwB,EAAErB,OAAO,CAACI,aAAa,CAAC;IACtE;;IAGD,IAAIc,aAAa,EAAE;;MAEfb,gBAAgB,CAACmB,KAAK,GAAGxB,OAAO,CAACwB,KAAK,IAAIC,SAAS;IACtD;IAEDpB,gBAAgB,CAACG,KAAK,GAAGR,OAAO,CAACQ,KAAK;;IAGtC,IAAIH,gBAAgB,CAACqB,WAAW,EAAE;MAC9B,IAAI,CAACjC,eAAe,CAACkC,UAAU,GAAGtB,gBAAgB,CAACqB,WAAW;IACjE,OAAM;MACH,MAAME,OAAO,GAAG,IAAI,CAACC,oBAAoB,CAAC7B,OAAO,CAAC;MAClD,IAAI4B,OAAO,EAAE;QACT,IAAI,CAACnC,eAAe,CAACqC,aAAa,GAAGF,OAAO;MAC/C;IACJ;;IAGD,MAAMG,aAAa,GAAI,MAAMjB,WAAW,CACpC,IAAI,CAAClB,UAAU,CAACoC,YAAY,CAAChB,IAAI,CAAC,IAAI,CAACpB,UAAU,CAAC,EAClDM,iBAAiB,CAAC+B,sBAAsB,EACxC,IAAI,CAACvC,MAAM,EACX,IAAI,CAACC,iBAAiB,EACtBK,OAAO,CAACI,aAAa,CACxB,CAAC,IAAI,CAACX,eAAe,EAAEY,gBAAgB,CAA0B;IAClE,OAAO0B,aAAa;;EAGxB;;AAEG;EACOF,oBAAoBA,CAC1B7B,OAAsC;IAEtC,IAAIA,OAAO,CAACkC,OAAO,EAAE;MACjB,OAAO;QACHC,UAAU,EAAEnC,OAAO,CAACkC,OAAO,CAACE,aAAa;QACzCC,IAAI,EAAEC,iBAAiB,CAACC;OAC3B;IACJ,OAAM,IAAIvC,OAAO,CAACwC,SAAS,EAAE;MAC1B,OAAO;QACHL,UAAU,EAAEnC,OAAO,CAACwC,SAAS;QAC7BH,IAAI,EAAEC,iBAAiB,CAACG;OAC3B;IACJ;IAED,OAAO,IAAI;;AAElB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}