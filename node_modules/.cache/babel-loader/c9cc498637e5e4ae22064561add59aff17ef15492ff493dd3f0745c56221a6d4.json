{"ast":null,"code":"/*! @azure/msal-common v15.7.0 2025-05-30 */\n'use strict';\n\nimport { addClientId, addScopes, addRedirectUri, addCorrelationId, addResponseMode, addClientInfo, addPrompt, addDomainHint, addSid, addLoginHint, addCcsOid, addCcsUpn, addNonce, addState, addClaims, addBrokerParameters, addInstanceAware } from '../request/RequestParameterBuilder.mjs';\nimport { CLIENT_ID, INSTANCE_AWARE } from '../constants/AADServerParamKeys.mjs';\nimport { PromptValue } from '../utils/Constants.mjs';\nimport { buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { mapToQueryString } from '../utils/UrlUtils.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { isInteractionRequiredError, InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { authorizationCodeMissingFromServerResponse, stateNotFound, invalidState, stateMismatch } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Returns map of parameters that are applicable to all calls to /authorize whether using PKCE or EAR\r\n * @param config\r\n * @param request\r\n * @param logger\r\n * @param performanceClient\r\n * @returns\r\n */\nfunction getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {\n  // generate the correlationId if not set by the user and add\n  const correlationId = request.correlationId;\n  const parameters = new Map();\n  addClientId(parameters, request.embeddedClientId || request.extraQueryParameters?.[CLIENT_ID] || authOptions.clientId);\n  const requestScopes = [...(request.scopes || []), ...(request.extraScopesToConsent || [])];\n  addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);\n  addRedirectUri(parameters, request.redirectUri);\n  addCorrelationId(parameters, correlationId);\n  // add response_mode. If not passed in it defaults to query.\n  addResponseMode(parameters, request.responseMode);\n  // add client_info=1\n  addClientInfo(parameters);\n  if (request.prompt) {\n    addPrompt(parameters, request.prompt);\n    performanceClient?.addFields({\n      prompt: request.prompt\n    }, correlationId);\n  }\n  if (request.domainHint) {\n    addDomainHint(parameters, request.domainHint);\n    performanceClient?.addFields({\n      domainHintFromRequest: true\n    }, correlationId);\n  }\n  // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n  if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n    // AAD will throw if prompt=select_account is passed with an account hint\n    if (request.sid && request.prompt === PromptValue.NONE) {\n      // SessionID is only used in silent calls\n      logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n      addSid(parameters, request.sid);\n      performanceClient?.addFields({\n        sidFromRequest: true\n      }, correlationId);\n    } else if (request.account) {\n      const accountSid = extractAccountSid(request.account);\n      let accountLoginHintClaim = extractLoginHint(request.account);\n      if (accountLoginHintClaim && request.domainHint) {\n        logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: \"domainHint\" param is set, skipping opaque \"login_hint\" claim. Please consider not passing domainHint`);\n        accountLoginHintClaim = null;\n      }\n      // If login_hint claim is present, use it over sid/username\n      if (accountLoginHintClaim) {\n        logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n        addLoginHint(parameters, accountLoginHintClaim);\n        performanceClient?.addFields({\n          loginHintFromClaim: true\n        }, correlationId);\n        try {\n          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n          addCcsOid(parameters, clientInfo);\n        } catch (e) {\n          logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n        }\n      } else if (accountSid && request.prompt === PromptValue.NONE) {\n        /*\r\n         * If account and loginHint are provided, we will check account first for sid before adding loginHint\r\n         * SessionId is only used in silent calls\r\n         */\n        logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n        addSid(parameters, accountSid);\n        performanceClient?.addFields({\n          sidFromClaim: true\n        }, correlationId);\n        try {\n          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n          addCcsOid(parameters, clientInfo);\n        } catch (e) {\n          logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n        }\n      } else if (request.loginHint) {\n        logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n        addLoginHint(parameters, request.loginHint);\n        addCcsUpn(parameters, request.loginHint);\n        performanceClient?.addFields({\n          loginHintFromRequest: true\n        }, correlationId);\n      } else if (request.account.username) {\n        // Fallback to account username if provided\n        logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n        addLoginHint(parameters, request.account.username);\n        performanceClient?.addFields({\n          loginHintFromUpn: true\n        }, correlationId);\n        try {\n          const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n          addCcsOid(parameters, clientInfo);\n        } catch (e) {\n          logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n        }\n      }\n    } else if (request.loginHint) {\n      logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n      addLoginHint(parameters, request.loginHint);\n      addCcsUpn(parameters, request.loginHint);\n      performanceClient?.addFields({\n        loginHintFromRequest: true\n      }, correlationId);\n    }\n  } else {\n    logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n  }\n  if (request.nonce) {\n    addNonce(parameters, request.nonce);\n  }\n  if (request.state) {\n    addState(parameters, request.state);\n  }\n  if (request.claims || authOptions.clientCapabilities && authOptions.clientCapabilities.length > 0) {\n    addClaims(parameters, request.claims, authOptions.clientCapabilities);\n  }\n  if (request.embeddedClientId) {\n    addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);\n  }\n  // If extraQueryParameters includes instance_aware its value will be added when extraQueryParameters are added\n  if (authOptions.instanceAware && (!request.extraQueryParameters || !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {\n    addInstanceAware(parameters);\n  }\n  return parameters;\n}\n/**\r\n * Returns authorize endpoint with given request parameters in the query string\r\n * @param authority\r\n * @param requestParameters\r\n * @returns\r\n */\nfunction getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {\n  const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);\n  return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);\n}\n/**\r\n * Handles the hash fragment response from public client code request. Returns a code response used by\r\n * the client to exchange for a token in acquireToken.\r\n * @param serverParams\r\n * @param cachedState\r\n */\nfunction getAuthorizationCodePayload(serverParams, cachedState) {\n  // Get code response\n  validateAuthorizationResponse(serverParams, cachedState);\n  // throw when there is no auth code in the response\n  if (!serverParams.code) {\n    throw createClientAuthError(authorizationCodeMissingFromServerResponse);\n  }\n  return serverParams;\n}\n/**\r\n * Function which validates server authorization code response.\r\n * @param serverResponseHash\r\n * @param requestState\r\n */\nfunction validateAuthorizationResponse(serverResponse, requestState) {\n  if (!serverResponse.state || !requestState) {\n    throw serverResponse.state ? createClientAuthError(stateNotFound, \"Cached State\") : createClientAuthError(stateNotFound, \"Server State\");\n  }\n  let decodedServerResponseState;\n  let decodedRequestState;\n  try {\n    decodedServerResponseState = decodeURIComponent(serverResponse.state);\n  } catch (e) {\n    throw createClientAuthError(invalidState, serverResponse.state);\n  }\n  try {\n    decodedRequestState = decodeURIComponent(requestState);\n  } catch (e) {\n    throw createClientAuthError(invalidState, serverResponse.state);\n  }\n  if (decodedServerResponseState !== decodedRequestState) {\n    throw createClientAuthError(stateMismatch);\n  }\n  // Check for error\n  if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n    const serverErrorNo = parseServerErrorNo(serverResponse);\n    if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n      throw new InteractionRequiredAuthError(serverResponse.error || \"\", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || \"\", serverResponse.trace_id || \"\", serverResponse.correlation_id || \"\", serverResponse.claims || \"\", serverErrorNo);\n    }\n    throw new ServerError(serverResponse.error || \"\", serverResponse.error_description, serverResponse.suberror, serverErrorNo);\n  }\n}\n/**\r\n * Get server error No from the error_uri\r\n * @param serverResponse\r\n * @returns\r\n */\nfunction parseServerErrorNo(serverResponse) {\n  const errorCodePrefix = \"code=\";\n  const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);\n  return errorCodePrefixIndex && errorCodePrefixIndex >= 0 ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length) : undefined;\n}\n/**\r\n * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n * @param account\r\n */\nfunction extractAccountSid(account) {\n  return account.idTokenClaims?.sid || null;\n}\nfunction extractLoginHint(account) {\n  return account.idTokenClaims?.login_hint || null;\n}\nexport { getAuthorizationCodePayload, getAuthorizeUrl, getStandardAuthorizeRequestParameters, validateAuthorizationResponse };","map":{"version":3,"names":["getStandardAuthorizeRequestParameters","authOptions","request","logger","performanceClient","correlationId","parameters","Map","addClientId","embeddedClientId","extraQueryParameters","CLIENT_ID","clientId","requestScopes","scopes","extraScopesToConsent","addScopes","authority","options","OIDCOptions","defaultScopes","addRedirectUri","redirectUri","addCorrelationId","addResponseMode","responseMode","addClientInfo","prompt","addPrompt","addFields","domainHint","addDomainHint","domainHintFromRequest","PromptValue","SELECT_ACCOUNT","sid","NONE","verbose","addSid","sidFromRequest","account","accountSid","extractAccountSid","accountLoginHintClaim","extractLoginHint","warning","addLoginHint","loginHintFromClaim","clientInfo","buildClientInfoFromHomeAccountId","homeAccountId","addCcsOid","e","sidFromClaim","loginHint","addCcsUpn","loginHintFromRequest","username","loginHintFromUpn","nonce","addNonce","state","addState","claims","clientCapabilities","length","addClaims","addBrokerParameters","instanceAware","Object","keys","includes","INSTANCE_AWARE","addInstanceAware","getAuthorizeUrl","requestParameters","encodeParams","queryString","mapToQueryString","UrlString","appendQueryString","authorizationEndpoint","getAuthorizationCodePayload","serverParams","cachedState","validateAuthorizationResponse","code","createClientAuthError","authorizationCodeMissingFromServerResponse","serverResponse","requestState","stateNotFound","decodedServerResponseState","decodedRequestState","decodeURIComponent","invalidState","stateMismatch","error","error_description","suberror","serverErrorNo","parseServerErrorNo","isInteractionRequiredError","InteractionRequiredAuthError","timestamp","trace_id","correlation_id","ServerError","errorCodePrefix","errorCodePrefixIndex","error_uri","lastIndexOf","substring","undefined","idTokenClaims","login_hint"],"sources":["/Users/yuri.narang/Desktop/bondly-workplace-community-hub/node_modules/@azure/msal-common/src/protocol/Authorize.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest.js\";\nimport * as RequestParameterBuilder from \"../request/RequestParameterBuilder.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport * as AADServerParamKeys from \"../constants/AADServerParamKeys.js\";\nimport { AuthOptions } from \"../config/ClientConfiguration.js\";\nimport { PromptValue } from \"../utils/Constants.js\";\nimport { AccountInfo } from \"../account/AccountInfo.js\";\nimport { Logger } from \"../logger/Logger.js\";\nimport { buildClientInfoFromHomeAccountId } from \"../account/ClientInfo.js\";\nimport { Authority } from \"../authority/Authority.js\";\nimport { mapToQueryString } from \"../utils/UrlUtils.js\";\nimport { UrlString } from \"../url/UrlString.js\";\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload.js\";\nimport { AuthorizeResponse } from \"../response/AuthorizeResponse.js\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError.js\";\nimport {\n    InteractionRequiredAuthError,\n    isInteractionRequiredError,\n} from \"../error/InteractionRequiredAuthError.js\";\nimport { ServerError } from \"../error/ServerError.js\";\nimport { StringDict } from \"../utils/MsalTypes.js\";\n\n/**\n * Returns map of parameters that are applicable to all calls to /authorize whether using PKCE or EAR\n * @param config\n * @param request\n * @param logger\n * @param performanceClient\n * @returns\n */\nexport function getStandardAuthorizeRequestParameters(\n    authOptions: AuthOptions,\n    request: CommonAuthorizationUrlRequest,\n    logger: Logger,\n    performanceClient?: IPerformanceClient\n): Map<string, string> {\n    // generate the correlationId if not set by the user and add\n    const correlationId = request.correlationId;\n\n    const parameters = new Map<string, string>();\n\n    RequestParameterBuilder.addClientId(\n        parameters,\n        request.embeddedClientId ||\n            request.extraQueryParameters?.[AADServerParamKeys.CLIENT_ID] ||\n            authOptions.clientId\n    );\n\n    const requestScopes = [\n        ...(request.scopes || []),\n        ...(request.extraScopesToConsent || []),\n    ];\n    RequestParameterBuilder.addScopes(\n        parameters,\n        requestScopes,\n        true,\n        authOptions.authority.options.OIDCOptions?.defaultScopes\n    );\n\n    RequestParameterBuilder.addRedirectUri(parameters, request.redirectUri);\n\n    RequestParameterBuilder.addCorrelationId(parameters, correlationId);\n\n    // add response_mode. If not passed in it defaults to query.\n    RequestParameterBuilder.addResponseMode(parameters, request.responseMode);\n\n    // add client_info=1\n    RequestParameterBuilder.addClientInfo(parameters);\n\n    if (request.prompt) {\n        RequestParameterBuilder.addPrompt(parameters, request.prompt);\n        performanceClient?.addFields({ prompt: request.prompt }, correlationId);\n    }\n\n    if (request.domainHint) {\n        RequestParameterBuilder.addDomainHint(parameters, request.domainHint);\n        performanceClient?.addFields(\n            { domainHintFromRequest: true },\n            correlationId\n        );\n    }\n\n    // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n        // AAD will throw if prompt=select_account is passed with an account hint\n        if (request.sid && request.prompt === PromptValue.NONE) {\n            // SessionID is only used in silent calls\n            logger.verbose(\n                \"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\"\n            );\n            RequestParameterBuilder.addSid(parameters, request.sid);\n            performanceClient?.addFields(\n                { sidFromRequest: true },\n                correlationId\n            );\n        } else if (request.account) {\n            const accountSid = extractAccountSid(request.account);\n            let accountLoginHintClaim = extractLoginHint(request.account);\n\n            if (accountLoginHintClaim && request.domainHint) {\n                logger.warning(\n                    `AuthorizationCodeClient.createAuthCodeUrlQueryString: \"domainHint\" param is set, skipping opaque \"login_hint\" claim. Please consider not passing domainHint`\n                );\n                accountLoginHintClaim = null;\n            }\n\n            // If login_hint claim is present, use it over sid/username\n            if (accountLoginHintClaim) {\n                logger.verbose(\n                    \"createAuthCodeUrlQueryString: login_hint claim present on account\"\n                );\n                RequestParameterBuilder.addLoginHint(\n                    parameters,\n                    accountLoginHintClaim\n                );\n                performanceClient?.addFields(\n                    { loginHintFromClaim: true },\n                    correlationId\n                );\n                try {\n                    const clientInfo = buildClientInfoFromHomeAccountId(\n                        request.account.homeAccountId\n                    );\n                    RequestParameterBuilder.addCcsOid(parameters, clientInfo);\n                } catch (e) {\n                    logger.verbose(\n                        \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                    );\n                }\n            } else if (accountSid && request.prompt === PromptValue.NONE) {\n                /*\n                 * If account and loginHint are provided, we will check account first for sid before adding loginHint\n                 * SessionId is only used in silent calls\n                 */\n                logger.verbose(\n                    \"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\"\n                );\n                RequestParameterBuilder.addSid(parameters, accountSid);\n                performanceClient?.addFields(\n                    { sidFromClaim: true },\n                    correlationId\n                );\n                try {\n                    const clientInfo = buildClientInfoFromHomeAccountId(\n                        request.account.homeAccountId\n                    );\n                    RequestParameterBuilder.addCcsOid(parameters, clientInfo);\n                } catch (e) {\n                    logger.verbose(\n                        \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                    );\n                }\n            } else if (request.loginHint) {\n                logger.verbose(\n                    \"createAuthCodeUrlQueryString: Adding login_hint from request\"\n                );\n                RequestParameterBuilder.addLoginHint(\n                    parameters,\n                    request.loginHint\n                );\n                RequestParameterBuilder.addCcsUpn(\n                    parameters,\n                    request.loginHint\n                );\n                performanceClient?.addFields(\n                    { loginHintFromRequest: true },\n                    correlationId\n                );\n            } else if (request.account.username) {\n                // Fallback to account username if provided\n                logger.verbose(\n                    \"createAuthCodeUrlQueryString: Adding login_hint from account\"\n                );\n                RequestParameterBuilder.addLoginHint(\n                    parameters,\n                    request.account.username\n                );\n                performanceClient?.addFields(\n                    { loginHintFromUpn: true },\n                    correlationId\n                );\n                try {\n                    const clientInfo = buildClientInfoFromHomeAccountId(\n                        request.account.homeAccountId\n                    );\n                    RequestParameterBuilder.addCcsOid(parameters, clientInfo);\n                } catch (e) {\n                    logger.verbose(\n                        \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                    );\n                }\n            }\n        } else if (request.loginHint) {\n            logger.verbose(\n                \"createAuthCodeUrlQueryString: No account, adding login_hint from request\"\n            );\n            RequestParameterBuilder.addLoginHint(parameters, request.loginHint);\n            RequestParameterBuilder.addCcsUpn(parameters, request.loginHint);\n            performanceClient?.addFields(\n                { loginHintFromRequest: true },\n                correlationId\n            );\n        }\n    } else {\n        logger.verbose(\n            \"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\"\n        );\n    }\n\n    if (request.nonce) {\n        RequestParameterBuilder.addNonce(parameters, request.nonce);\n    }\n\n    if (request.state) {\n        RequestParameterBuilder.addState(parameters, request.state);\n    }\n\n    if (\n        request.claims ||\n        (authOptions.clientCapabilities &&\n            authOptions.clientCapabilities.length > 0)\n    ) {\n        RequestParameterBuilder.addClaims(\n            parameters,\n            request.claims,\n            authOptions.clientCapabilities\n        );\n    }\n\n    if (request.embeddedClientId) {\n        RequestParameterBuilder.addBrokerParameters(\n            parameters,\n            authOptions.clientId,\n            authOptions.redirectUri\n        );\n    }\n\n    // If extraQueryParameters includes instance_aware its value will be added when extraQueryParameters are added\n    if (\n        authOptions.instanceAware &&\n        (!request.extraQueryParameters ||\n            !Object.keys(request.extraQueryParameters).includes(\n                AADServerParamKeys.INSTANCE_AWARE\n            ))\n    ) {\n        RequestParameterBuilder.addInstanceAware(parameters);\n    }\n\n    return parameters;\n}\n\n/**\n * Returns authorize endpoint with given request parameters in the query string\n * @param authority\n * @param requestParameters\n * @returns\n */\nexport function getAuthorizeUrl(\n    authority: Authority,\n    requestParameters: Map<string, string>,\n    encodeParams?: boolean,\n    extraQueryParameters?: StringDict | undefined\n): string {\n    const queryString = mapToQueryString(\n        requestParameters,\n        encodeParams,\n        extraQueryParameters\n    );\n    return UrlString.appendQueryString(\n        authority.authorizationEndpoint,\n        queryString\n    );\n}\n\n/**\n * Handles the hash fragment response from public client code request. Returns a code response used by\n * the client to exchange for a token in acquireToken.\n * @param serverParams\n * @param cachedState\n */\nexport function getAuthorizationCodePayload(\n    serverParams: AuthorizeResponse,\n    cachedState: string\n): AuthorizationCodePayload {\n    // Get code response\n    validateAuthorizationResponse(serverParams, cachedState);\n\n    // throw when there is no auth code in the response\n    if (!serverParams.code) {\n        throw createClientAuthError(\n            ClientAuthErrorCodes.authorizationCodeMissingFromServerResponse\n        );\n    }\n\n    return serverParams as AuthorizationCodePayload;\n}\n\n/**\n * Function which validates server authorization code response.\n * @param serverResponseHash\n * @param requestState\n */\nexport function validateAuthorizationResponse(\n    serverResponse: AuthorizeResponse,\n    requestState: string\n): void {\n    if (!serverResponse.state || !requestState) {\n        throw serverResponse.state\n            ? createClientAuthError(\n                  ClientAuthErrorCodes.stateNotFound,\n                  \"Cached State\"\n              )\n            : createClientAuthError(\n                  ClientAuthErrorCodes.stateNotFound,\n                  \"Server State\"\n              );\n    }\n\n    let decodedServerResponseState: string;\n    let decodedRequestState: string;\n\n    try {\n        decodedServerResponseState = decodeURIComponent(serverResponse.state);\n    } catch (e) {\n        throw createClientAuthError(\n            ClientAuthErrorCodes.invalidState,\n            serverResponse.state\n        );\n    }\n\n    try {\n        decodedRequestState = decodeURIComponent(requestState);\n    } catch (e) {\n        throw createClientAuthError(\n            ClientAuthErrorCodes.invalidState,\n            serverResponse.state\n        );\n    }\n\n    if (decodedServerResponseState !== decodedRequestState) {\n        throw createClientAuthError(ClientAuthErrorCodes.stateMismatch);\n    }\n\n    // Check for error\n    if (\n        serverResponse.error ||\n        serverResponse.error_description ||\n        serverResponse.suberror\n    ) {\n        const serverErrorNo = parseServerErrorNo(serverResponse);\n        if (\n            isInteractionRequiredError(\n                serverResponse.error,\n                serverResponse.error_description,\n                serverResponse.suberror\n            )\n        ) {\n            throw new InteractionRequiredAuthError(\n                serverResponse.error || \"\",\n                serverResponse.error_description,\n                serverResponse.suberror,\n                serverResponse.timestamp || \"\",\n                serverResponse.trace_id || \"\",\n                serverResponse.correlation_id || \"\",\n                serverResponse.claims || \"\",\n                serverErrorNo\n            );\n        }\n\n        throw new ServerError(\n            serverResponse.error || \"\",\n            serverResponse.error_description,\n            serverResponse.suberror,\n            serverErrorNo\n        );\n    }\n}\n\n/**\n * Get server error No from the error_uri\n * @param serverResponse\n * @returns\n */\nfunction parseServerErrorNo(\n    serverResponse: AuthorizeResponse\n): string | undefined {\n    const errorCodePrefix = \"code=\";\n    const errorCodePrefixIndex =\n        serverResponse.error_uri?.lastIndexOf(errorCodePrefix);\n    return errorCodePrefixIndex && errorCodePrefixIndex >= 0\n        ? serverResponse.error_uri?.substring(\n              errorCodePrefixIndex + errorCodePrefix.length\n          )\n        : undefined;\n}\n\n/**\n * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n * @param account\n */\nfunction extractAccountSid(account: AccountInfo): string | null {\n    return account.idTokenClaims?.sid || null;\n}\n\nfunction extractLoginHint(account: AccountInfo): string | null {\n    return account.idTokenClaims?.login_hint || null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}