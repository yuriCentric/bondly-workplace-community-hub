{"ast":null,"code":"/*! @azure/msal-browser v4.13.1 2025-06-10 */\n'use strict';\n\nimport { createNetworkError } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { HTTP_REQUEST_TYPE } from '../utils/BrowserConstants.mjs';\nimport { getRequestFailed, noNetworkConnectivity, failedToParseResponse, postRequestFailed, failedToBuildHeaders, failedToParseHeaders } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the Fetch API for GET and POST requests. See more here: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\r\n */\nclass FetchClient {\n  /**\r\n   * Fetch Client for REST endpoints - Get request\r\n   * @param url\r\n   * @param headers\r\n   * @param body\r\n   */\n  async sendGetRequestAsync(url, options) {\n    let response;\n    let responseHeaders = {};\n    let responseStatus = 0;\n    const reqHeaders = getFetchHeaders(options);\n    try {\n      response = await fetch(url, {\n        method: HTTP_REQUEST_TYPE.GET,\n        headers: reqHeaders\n      });\n    } catch (e) {\n      throw createNetworkError(createBrowserAuthError(window.navigator.onLine ? getRequestFailed : noNetworkConnectivity), undefined, undefined, e);\n    }\n    responseHeaders = getHeaderDict(response.headers);\n    try {\n      responseStatus = response.status;\n      return {\n        headers: responseHeaders,\n        body: await response.json(),\n        status: responseStatus\n      };\n    } catch (e) {\n      throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders, e);\n    }\n  }\n  /**\r\n   * Fetch Client for REST endpoints - Post request\r\n   * @param url\r\n   * @param headers\r\n   * @param body\r\n   */\n  async sendPostRequestAsync(url, options) {\n    const reqBody = options && options.body || \"\";\n    const reqHeaders = getFetchHeaders(options);\n    let response;\n    let responseStatus = 0;\n    let responseHeaders = {};\n    try {\n      response = await fetch(url, {\n        method: HTTP_REQUEST_TYPE.POST,\n        headers: reqHeaders,\n        body: reqBody\n      });\n    } catch (e) {\n      throw createNetworkError(createBrowserAuthError(window.navigator.onLine ? postRequestFailed : noNetworkConnectivity), undefined, undefined, e);\n    }\n    responseHeaders = getHeaderDict(response.headers);\n    try {\n      responseStatus = response.status;\n      return {\n        headers: responseHeaders,\n        body: await response.json(),\n        status: responseStatus\n      };\n    } catch (e) {\n      throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders, e);\n    }\n  }\n}\n/**\r\n * Get Fetch API Headers object from string map\r\n * @param inputHeaders\r\n */\nfunction getFetchHeaders(options) {\n  try {\n    const headers = new Headers();\n    if (!(options && options.headers)) {\n      return headers;\n    }\n    const optionsHeaders = options.headers;\n    Object.entries(optionsHeaders).forEach(([key, value]) => {\n      headers.append(key, value);\n    });\n    return headers;\n  } catch (e) {\n    throw createNetworkError(createBrowserAuthError(failedToBuildHeaders), undefined, undefined, e);\n  }\n}\n/**\r\n * Returns object representing response headers\r\n * @param headers\r\n * @returns\r\n */\nfunction getHeaderDict(headers) {\n  try {\n    const headerDict = {};\n    headers.forEach((value, key) => {\n      headerDict[key] = value;\n    });\n    return headerDict;\n  } catch (e) {\n    throw createBrowserAuthError(failedToParseHeaders);\n  }\n}\nexport { FetchClient };","map":{"version":3,"names":["FetchClient","sendGetRequestAsync","url","options","response","responseHeaders","responseStatus","reqHeaders","getFetchHeaders","fetch","method","HTTP_REQUEST_TYPE","GET","headers","e","createNetworkError","createBrowserAuthError","window","navigator","onLine","getRequestFailed","noNetworkConnectivity","undefined","getHeaderDict","status","body","json","failedToParseResponse","sendPostRequestAsync","reqBody","POST","postRequestFailed","Headers","optionsHeaders","Object","entries","forEach","key","value","append","failedToBuildHeaders","headerDict","failedToParseHeaders"],"sources":["/Users/yuri.narang/Desktop/bondly-workplace-community-hub/node_modules/@azure/msal-browser/src/network/FetchClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    INetworkModule,\n    NetworkRequestOptions,\n    NetworkResponse,\n    createNetworkError,\n} from \"@azure/msal-common/browser\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError.js\";\nimport { HTTP_REQUEST_TYPE } from \"../utils/BrowserConstants.js\";\n\n/**\n * This class implements the Fetch API for GET and POST requests. See more here: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n */\nexport class FetchClient implements INetworkModule {\n    /**\n     * Fetch Client for REST endpoints - Get request\n     * @param url\n     * @param headers\n     * @param body\n     */\n    async sendGetRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions\n    ): Promise<NetworkResponse<T>> {\n        let response: Response;\n        let responseHeaders: Record<string, string> = {};\n        let responseStatus = 0;\n        const reqHeaders = getFetchHeaders(options);\n        try {\n            response = await fetch(url, {\n                method: HTTP_REQUEST_TYPE.GET,\n                headers: reqHeaders,\n            });\n        } catch (e) {\n            throw createNetworkError(\n                createBrowserAuthError(\n                    window.navigator.onLine\n                        ? BrowserAuthErrorCodes.getRequestFailed\n                        : BrowserAuthErrorCodes.noNetworkConnectivity\n                ),\n                undefined,\n                undefined,\n                e as Error\n            );\n        }\n\n        responseHeaders = getHeaderDict(response.headers);\n        try {\n            responseStatus = response.status;\n            return {\n                headers: responseHeaders,\n                body: (await response.json()) as T,\n                status: responseStatus,\n            };\n        } catch (e) {\n            throw createNetworkError(\n                createBrowserAuthError(\n                    BrowserAuthErrorCodes.failedToParseResponse\n                ),\n                responseStatus,\n                responseHeaders,\n                e as Error\n            );\n        }\n    }\n\n    /**\n     * Fetch Client for REST endpoints - Post request\n     * @param url\n     * @param headers\n     * @param body\n     */\n    async sendPostRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions\n    ): Promise<NetworkResponse<T>> {\n        const reqBody = (options && options.body) || \"\";\n        const reqHeaders = getFetchHeaders(options);\n\n        let response: Response;\n        let responseStatus = 0;\n        let responseHeaders: Record<string, string> = {};\n        try {\n            response = await fetch(url, {\n                method: HTTP_REQUEST_TYPE.POST,\n                headers: reqHeaders,\n                body: reqBody,\n            });\n        } catch (e) {\n            throw createNetworkError(\n                createBrowserAuthError(\n                    window.navigator.onLine\n                        ? BrowserAuthErrorCodes.postRequestFailed\n                        : BrowserAuthErrorCodes.noNetworkConnectivity\n                ),\n                undefined,\n                undefined,\n                e as Error\n            );\n        }\n\n        responseHeaders = getHeaderDict(response.headers);\n        try {\n            responseStatus = response.status;\n            return {\n                headers: responseHeaders,\n                body: (await response.json()) as T,\n                status: responseStatus,\n            };\n        } catch (e) {\n            throw createNetworkError(\n                createBrowserAuthError(\n                    BrowserAuthErrorCodes.failedToParseResponse\n                ),\n                responseStatus,\n                responseHeaders,\n                e as Error\n            );\n        }\n    }\n}\n\n/**\n * Get Fetch API Headers object from string map\n * @param inputHeaders\n */\nfunction getFetchHeaders(options?: NetworkRequestOptions): Headers {\n    try {\n        const headers = new Headers();\n        if (!(options && options.headers)) {\n            return headers;\n        }\n        const optionsHeaders = options.headers;\n        Object.entries(optionsHeaders).forEach(([key, value]) => {\n            headers.append(key, value);\n        });\n        return headers;\n    } catch (e) {\n        throw createNetworkError(\n            createBrowserAuthError(BrowserAuthErrorCodes.failedToBuildHeaders),\n            undefined,\n            undefined,\n            e as Error\n        );\n    }\n}\n\n/**\n * Returns object representing response headers\n * @param headers\n * @returns\n */\nfunction getHeaderDict(headers: Headers): Record<string, string> {\n    try {\n        const headerDict: Record<string, string> = {};\n        headers.forEach((value: string, key: string) => {\n            headerDict[key] = value;\n        });\n        return headerDict;\n    } catch (e) {\n        throw createBrowserAuthError(\n            BrowserAuthErrorCodes.failedToParseHeaders\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}