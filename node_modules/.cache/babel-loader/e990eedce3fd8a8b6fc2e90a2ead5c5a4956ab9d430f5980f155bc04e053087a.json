{"ast":null,"code":"/*! @azure/msal-common v15.7.0 2025-05-30 */\n'use strict';\n\nimport { Constants, HttpStatus, RegionDiscoverySources } from '../utils/Constants.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass RegionDiscovery {\n  constructor(networkInterface, logger, performanceClient, correlationId) {\n    this.networkInterface = networkInterface;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n  }\n  /**\r\n   * Detect the region from the application's environment.\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  async detectRegion(environmentRegion, regionDiscoveryMetadata) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n    // Initialize auto detected region with the region from the envrionment\n    let autodetectedRegionName = environmentRegion;\n    // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n    if (!autodetectedRegionName) {\n      const options = RegionDiscovery.IMDS_OPTIONS;\n      try {\n        const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);\n        if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {\n          autodetectedRegionName = localIMDSVersionResponse.body;\n          regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n        }\n        // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n        if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {\n          const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);\n          if (!currentIMDSVersion) {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return null;\n          }\n          const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);\n          if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {\n            autodetectedRegionName = currentIMDSVersionResponse.body;\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n          }\n        }\n      } catch (e) {\n        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        return null;\n      }\n    } else {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n    }\n    // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n    if (!autodetectedRegionName) {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n    }\n    return autodetectedRegionName || null;\n  }\n  /**\r\n   * Make the call to the IMDS endpoint\r\n   *\r\n   * @param imdsEndpointUrl\r\n   * @returns Promise<NetworkResponse<string>>\r\n   */\n  async getRegionFromIMDS(version, options) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n    return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n  }\n  /**\r\n   * Get the most recent version of the IMDS endpoint available\r\n   *\r\n   * @returns Promise<string | null>\r\n   */\n  async getCurrentVersion(options) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n    try {\n      const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n      // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n      if (response.status === HttpStatus.BAD_REQUEST && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n        return response.body[\"newest-versions\"][0];\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n// Options for the IMDS endpoint request\nRegionDiscovery.IMDS_OPTIONS = {\n  headers: {\n    Metadata: \"true\"\n  }\n};\nexport { RegionDiscovery };","map":{"version":3,"names":["RegionDiscovery","constructor","networkInterface","logger","performanceClient","correlationId","detectRegion","environmentRegion","regionDiscoveryMetadata","addQueueMeasurement","PerformanceEvents","RegionDiscoveryDetectRegion","autodetectedRegionName","options","IMDS_OPTIONS","localIMDSVersionResponse","invokeAsync","getRegionFromIMDS","bind","RegionDiscoveryGetRegionFromIMDS","Constants","IMDS_VERSION","status","HttpStatus","SUCCESS","body","region_source","RegionDiscoverySources","IMDS","BAD_REQUEST","currentIMDSVersion","getCurrentVersion","RegionDiscoveryGetCurrentVersion","FAILED_AUTO_DETECTION","currentIMDSVersionResponse","e","ENVIRONMENT_VARIABLE","version","sendGetRequestAsync","IMDS_ENDPOINT","IMDS_TIMEOUT","response","length","headers","Metadata"],"sources":["/Users/yuri.narang/Desktop/bondly-workplace-community-hub/node_modules/@azure/msal-common/src/authority/RegionDiscovery.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule } from \"../network/INetworkModule.js\";\nimport { NetworkResponse } from \"../network/NetworkResponse.js\";\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse.js\";\nimport {\n    Constants,\n    HttpStatus,\n    RegionDiscoverySources,\n} from \"../utils/Constants.js\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata.js\";\nimport { ImdsOptions } from \"./ImdsOptions.js\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient.js\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent.js\";\nimport { invokeAsync } from \"../utils/FunctionWrappers.js\";\nimport { Logger } from \"../logger/Logger.js\";\n\nexport class RegionDiscovery {\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Logger\n    private logger: Logger;\n    // Performance client\n    protected performanceClient: IPerformanceClient | undefined;\n    // CorrelationId\n    protected correlationId: string | undefined;\n    // Options for the IMDS endpoint request\n    protected static IMDS_OPTIONS: ImdsOptions = {\n        headers: {\n            Metadata: \"true\",\n        },\n    };\n\n    constructor(\n        networkInterface: INetworkModule,\n        logger: Logger,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ) {\n        this.networkInterface = networkInterface;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n        this.correlationId = correlationId;\n    }\n\n    /**\n     * Detect the region from the application's environment.\n     *\n     * @returns Promise<string | null>\n     */\n    public async detectRegion(\n        environmentRegion: string | undefined,\n        regionDiscoveryMetadata: RegionDiscoveryMetadata\n    ): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryDetectRegion,\n            this.correlationId\n        );\n\n        // Initialize auto detected region with the region from the envrionment\n        let autodetectedRegionName = environmentRegion;\n\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n        if (!autodetectedRegionName) {\n            const options = RegionDiscovery.IMDS_OPTIONS;\n\n            try {\n                const localIMDSVersionResponse = await invokeAsync(\n                    this.getRegionFromIMDS.bind(this),\n                    PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n                    this.logger,\n                    this.performanceClient,\n                    this.correlationId\n                )(Constants.IMDS_VERSION, options);\n                if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {\n                    autodetectedRegionName = localIMDSVersionResponse.body;\n                    regionDiscoveryMetadata.region_source =\n                        RegionDiscoverySources.IMDS;\n                }\n\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n                if (\n                    localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST\n                ) {\n                    const currentIMDSVersion = await invokeAsync(\n                        this.getCurrentVersion.bind(this),\n                        PerformanceEvents.RegionDiscoveryGetCurrentVersion,\n                        this.logger,\n                        this.performanceClient,\n                        this.correlationId\n                    )(options);\n                    if (!currentIMDSVersion) {\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                        return null;\n                    }\n\n                    const currentIMDSVersionResponse = await invokeAsync(\n                        this.getRegionFromIMDS.bind(this),\n                        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n                        this.logger,\n                        this.performanceClient,\n                        this.correlationId\n                    )(currentIMDSVersion, options);\n                    if (\n                        currentIMDSVersionResponse.status === HttpStatus.SUCCESS\n                    ) {\n                        autodetectedRegionName =\n                            currentIMDSVersionResponse.body;\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.IMDS;\n                    }\n                }\n            } catch (e) {\n                regionDiscoveryMetadata.region_source =\n                    RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                return null;\n            }\n        } else {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n        }\n\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n        if (!autodetectedRegionName) {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        }\n\n        return autodetectedRegionName || null;\n    }\n\n    /**\n     * Make the call to the IMDS endpoint\n     *\n     * @param imdsEndpointUrl\n     * @returns Promise<NetworkResponse<string>>\n     */\n    private async getRegionFromIMDS(\n        version: string,\n        options: ImdsOptions\n    ): Promise<NetworkResponse<string>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n            this.correlationId\n        );\n        return this.networkInterface.sendGetRequestAsync<string>(\n            `${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`,\n            options,\n            Constants.IMDS_TIMEOUT\n        );\n    }\n\n    /**\n     * Get the most recent version of the IMDS endpoint available\n     *\n     * @returns Promise<string | null>\n     */\n    private async getCurrentVersion(\n        options: ImdsOptions\n    ): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryGetCurrentVersion,\n            this.correlationId\n        );\n        try {\n            const response =\n                await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(\n                    `${Constants.IMDS_ENDPOINT}?format=json`,\n                    options\n                );\n\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (\n                response.status === HttpStatus.BAD_REQUEST &&\n                response.body &&\n                response.body[\"newest-versions\"] &&\n                response.body[\"newest-versions\"].length > 0\n            ) {\n                return response.body[\"newest-versions\"][0];\n            }\n\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}